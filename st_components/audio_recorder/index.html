<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Noto Sans Devanagari', -apple-system, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100%;
    background: transparent;
    padding: 12px 8px;
  }

  .mic-area {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 140px;
    height: 140px;
    margin-bottom: 12px;
  }

  /* Pulsing rings when recording */
  .ring {
    position: absolute;
    border-radius: 50%;
    border: 3px solid rgba(255, 107, 53, 0.3);
    width: 140px; height: 140px;
    display: none;
  }
  .recording .ring {
    display: block;
    animation: ring-expand 1.8s ease-out infinite;
  }
  .ring:nth-child(2) { animation-delay: 0.5s; }
  .ring:nth-child(3) { animation-delay: 1.0s; }
  @keyframes ring-expand {
    0%   { transform: scale(1); opacity: 0.6; }
    100% { transform: scale(1.8); opacity: 0; }
  }

  .mic-btn {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3.2rem;
    position: relative;
    z-index: 2;
    transition: all 0.25s ease;
    background: linear-gradient(135deg, #FF6B35, #E55A2B);
    color: white;
    box-shadow: 0 6px 24px rgba(255, 107, 53, 0.4);
  }
  .mic-btn:hover { transform: scale(1.05); }
  .mic-btn:active { transform: scale(0.95); }

  .mic-btn.recording {
    background: linear-gradient(135deg, #D32F2F, #B71C1C);
    box-shadow: 0 6px 24px rgba(211, 47, 47, 0.4);
    animation: mic-pulse 1s infinite;
  }
  @keyframes mic-pulse {
    0%, 100% { transform: scale(1); }
    50%      { transform: scale(1.04); }
  }

  .mic-icon {
    width: 44px; height: 44px; fill: white;
  }
  .stop-icon {
    width: 32px; height: 32px; fill: white;
  }

  .status {
    font-size: 1.1rem;
    color: #666;
    text-align: center;
    min-height: 28px;
    margin-bottom: 4px;
  }
  .status.recording-status {
    color: #D32F2F;
    font-weight: 600;
    animation: blink 1s infinite;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50%      { opacity: 0.4; }
  }

  .timer {
    font-size: 0.9rem;
    color: #999;
    min-height: 20px;
  }
</style>
</head>
<body>

<div class="mic-area" id="micArea">
  <div class="ring"></div>
  <div class="ring"></div>
  <div class="ring"></div>
  <button class="mic-btn" id="micBtn" title="Record">
    <svg class="mic-icon" id="micIcon" viewBox="0 0 24 24">
      <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
      <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
    </svg>
    <svg class="stop-icon" id="stopIcon" viewBox="0 0 24 24" style="display:none;">
      <rect x="6" y="6" width="12" height="12" rx="2" />
    </svg>
  </button>
</div>

<div class="status" id="status"></div>
<div class="timer" id="timer"></div>

<script>
// ── Streamlit Component Communication ──────────────────────────
function sendToStreamlit(type, data) {
  window.parent.postMessage({
    isStreamlitMessage: true,
    type: type,
    ...data
  }, "*");
}
function setComponentValue(value) {
  sendToStreamlit("streamlit:setComponentValue", { value: value });
}
function setFrameHeight(h) {
  sendToStreamlit("streamlit:setFrameHeight", { height: h });
}

// ── Args from Streamlit ────────────────────────────────────────
let currentLang = "hi";
window.addEventListener("message", (e) => {
  if (e.data && e.data.type === "streamlit:render") {
    const args = e.data.args || {};
    currentLang = args.lang || "hi";
    updateLabels();
  }
});

// ── Translations ───────────────────────────────────────────────
const labels = {
  hi: {
    tapToSpeak:  "माइक दबाएँ और बोलें",
    listening:   "सुन रहा हूँ…",
    processing:  "समझ रहा हूँ…",
    error:       "माइक में गड़बड़ — कृपया अनुमति दें",
    done:        "भेजा गया!",
  },
  en: {
    tapToSpeak:  "Tap the mic and speak",
    listening:   "Listening…",
    processing:  "Processing…",
    error:       "Mic error — please allow access",
    done:        "Sent!",
  }
};

function L(key) {
  return (labels[currentLang] || labels["hi"])[key] || key;
}

// ── DOM refs ───────────────────────────────────────────────────
const micBtn    = document.getElementById("micBtn");
const micIcon   = document.getElementById("micIcon");
const stopIcon  = document.getElementById("stopIcon");
const micArea   = document.getElementById("micArea");
const statusEl  = document.getElementById("status");
const timerEl   = document.getElementById("timer");

let mediaRecorder = null;
let audioChunks   = [];
let isRecording   = false;
let startTime     = 0;
let timerInterval = null;
const MAX_DURATION = 15000; // 15 seconds max

function updateLabels() {
  if (!isRecording) {
    statusEl.textContent = L("tapToSpeak");
    statusEl.className = "status";
  }
}

// ── Recording logic ────────────────────────────────────────────
micBtn.addEventListener("click", async () => {
  if (isRecording) {
    stopRecording();
  } else {
    await startRecording();
  }
});

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true }
    });

    // Prefer webm (Chrome) → fall back to whatever is available
    const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
      ? "audio/webm;codecs=opus"
      : "audio/webm";

    mediaRecorder = new MediaRecorder(stream, { mimeType });
    audioChunks = [];

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      stream.getTracks().forEach(t => t.stop());
      const blob = new Blob(audioChunks, { type: mimeType });
      blobToBase64(blob).then(b64 => {
        statusEl.textContent = L("processing");
        statusEl.className = "status";
        // Send base64 audio to Streamlit
        setComponentValue(b64);
        setTimeout(() => {
          statusEl.textContent = L("done");
          setTimeout(() => { statusEl.textContent = L("tapToSpeak"); }, 1500);
        }, 300);
      });
    };

    mediaRecorder.start(250); // collect in 250ms chunks
    isRecording = true;
    startTime = Date.now();

    // UI updates
    micBtn.classList.add("recording");
    micArea.classList.add("recording");
    micIcon.style.display = "none";
    stopIcon.style.display = "block";
    statusEl.textContent = L("listening");
    statusEl.className = "status recording-status";

    // Timer
    timerInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      timerEl.textContent = `${elapsed}s`;
    }, 1000);

    // Auto-stop after MAX_DURATION
    setTimeout(() => {
      if (isRecording) stopRecording();
    }, MAX_DURATION);

  } catch (err) {
    console.error("Mic error:", err);
    statusEl.textContent = L("error");
    statusEl.className = "status";
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
  }
  isRecording = false;
  clearInterval(timerInterval);
  timerEl.textContent = "";

  // UI reset
  micBtn.classList.remove("recording");
  micArea.classList.remove("recording");
  micIcon.style.display = "block";
  stopIcon.style.display = "none";
}

// ── Helpers ────────────────────────────────────────────────────
function blobToBase64(blob) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // Strip the data:audio/xxx;base64, prefix
      const b64 = reader.result.split(",")[1];
      resolve(b64);
    };
    reader.readAsDataURL(blob);
  });
}

// ── Init ───────────────────────────────────────────────────────
updateLabels();
sendToStreamlit("streamlit:componentReady", { apiVersion: 1 });
setFrameHeight(210);
</script>
</body>
</html>
